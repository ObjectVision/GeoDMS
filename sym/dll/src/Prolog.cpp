//<HEADER> 
/*
Data & Model Server (DMS) is a server written in C++ for DSS applications. 
Version: see srv/dms/rtc/dll/src/RtcVersion.h for version info.

Copyright (C) 1998-2004  YUSE GSO Object Vision BV. 

Documentation on using the Data & Model Server software can be found at:
http://www.ObjectVision.nl/DMS/

See additional guidelines and notes in srv/dms/Readme-srv.txt 

This library is free software; you can use, redistribute, and/or
modify it under the terms of the GNU General Public License version 2 
(the License) as published by the Free Software Foundation,
provided that this entire header notice and readme-srv.txt is preserved.

See LICENSE.TXT for terms of distribution or look at our web site:
http://www.objectvision.nl/DMS/License.txt
or alternatively at: http://www.gnu.org/copyleft/gpl.html

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details. However, specific warranties might be
granted by an additional written contract for support, assistance and/or development
*/
//</HEADER>
#include "SymPch.h"

#if defined(CC_PRAGMAHDRSTOP)
#pragma hdrstop
#endif //defined(CC_PRAGMAHDRSTOP)

#include "dbg/debug.h"
#include "dbg/DebugCast.h"
#include "ser/AsString.h"

#if defined(MG_DEBUG)
#define MG_DEBUG_PROLOG 3
#endif

#include "Prolog.h"

/****************** renumbering                   *******************/

// Variable stamping:
typedef UInt32 TTimeStamp;

struct NrVar : public LispRef
{
	NrVar(LispPtr x, TTimeStamp n)
		:	LispRef(x.GetSymbID(), n)
	{
		dms_assert(x.IsVar());
	}
};

LispRef Renum(LispPtr x, TTimeStamp n)
{
	if (x.IsVar())
		return NrVar(x,n);
	if (!x.IsRealList())
		return x;
	return LispRef(Renum(x.Left(),n),Renum(x.Right(),n));
}

/****************** Unifications                  *******************/

bool Occur(LispPtr x, LispPtr t)
{
	if (x==t) return true;
	if (!t.IsRealList()) return false;
	return (Occur(x,t.Left()) && Occur(x,t.Right()));
}

AssocList UnifyRobinson(LispPtr t1, LispPtr t2, AssocListPtr s = AssocList())
	//	See: [Boizumault93], p.17
{
	DBG_START("UnifyRobinson", "", false);
	DBG_TRACE(("t1   :%s", AsString(t1).c_str()));
	DBG_TRACE(("t2   :%s", AsString(t2).c_str()));
	DBG_TRACE(("Assoc:%s", AsString(s).c_str()));
	if (t1.IsVar() || t2.IsVar())
	{
		if (t1==t2)
			return s;
		LispPtr x, t;
		if (t1.IsVar()) { x=t1; t=t2; } else { x=t2; t=t1; }
		if (Occur(x,t))
			return AssocList::failed();

		return Add(s, Assoc(x, t));
	}
	if (!t1.IsRealList())
	{
		if (t1==t2)
			return s;
		return AssocList::failed();
	}
	if (!t2.IsRealList())
		return AssocList::failed();
	AssocList new_s = UnifyRobinson(t1.Left(),t2.Left(),s);
	if (new_s.IsFailed())
		return AssocList::failed();
	return
		UnifyRobinson(
			new_s.ApplyMany(t1.Right()),
			new_s.ApplyMany(t2.Right()),new_s);
}


LispRef rep(AssocListPtr s, AssocListPtr e, LispPtr x)
	//	See: [Boizumault93], p.21
{
	return e.LookupRecursive(x.IsVar() ? s.LookupRecursive(x) : x);
}

/*
	The following Base Reduction algorithm is based on a version
	described by M. Van Caneghem. T is the initial system, which
	is tried to be transformed into an equivalent system S.
*/

AssocList ReduceCaneghem(AssocList T)
	//	See: [Boizumault93], p.21; [Caneghem84]
{
	bool success = true;
	AssocList S, // resulting system
				 E; // equations generated by the reduction
	while (success && !T.IsEmpty())
	{
		Assoc eq = T.First();
		LispRef s1=rep(S,E,eq.Key());
		LispRef t1=rep(S,E,eq.Val());
		T = T.Tail();
		if (!(s1 == t1))
		{
			if (s1.IsVar() || t1.IsVar())
				if (s1.IsVar())
					S=AssocList(Assoc(s1,t1),S);
				else
					S=AssocList(Assoc(t1,s1),S);
			else
				if (!s1.IsRealList())
					success=(s1==t1);
				else
				if (!t1.IsRealList())
						success=false;
					else
					{
						E=AssocList(Assoc(      s1 ,      t1 ),E);
						T=AssocList(Assoc(s1.Left (),t1.Left ()),T);
						T=AssocList(Assoc(s1.Right(),t1.Right()),T);
					}
		}
	}
	if (success)
		return S;
	else
		return AssocList::failed();
}

AssocList Unify(LispPtr x, LispPtr y)
{
	return ReduceCaneghem(AssocList(Assoc(x,y),AssocList()));
}

/****************** goal seeker                   *******************/


/*
 SelectRules substracts Rules from the RuleBase for proving a Goal.
 The variables in the rules are renumbered by a new TTimeStamp in order
 not to conflict with existing binding.

 OPT: Preliminary selection, filtering and indexing for this can be done
 on the basis of signature and/or functor in order to have less renumbering
 and unification attempts. Now, all rules are translated.
*/

RuleList SelectRules(RuleList::ptr_type ruleBase, Predicate::ptr_type /*goal*/, TTimeStamp chr)
{
	return Renum(ruleBase, chr);
}

// Func:   Prove
// params: List of goals and assocs
//         are in Renumbered-style with all timestamps < chr
//	returns: a solution, or fail
//				if a solution is found, it is returned as an env.
//	See: [Boizumault93], p.45

AnswerList Prove(
		RuleList::ptr_type      ruleBase, 
		PredicateList::ptr_type gl,// goallist, Renumbered < chr
		AssocList::ptr_type     e, // Environment, Renumbered
		int   chr)		           // Time-indicator.
{
	if (gl.IsEmpty())
		return List1<Answer>(SayAnswer(e));

#ifdef MG_DEBUG_PROLOG
	SharedStr chrStr = AsString(chr);
	DBG_START("Prove", chrStr.c_str(), true);
#endif MG_DEBUG_PROLOG

#if MG_DEBUG_PROLOG > 2
	DBG_TRACE(("Goal-list  = %s", AsString(gl).c_str()));
#endif MG_DEBUG_PROLOG > 2
	Predicate::ptr_type     g = gl.Head(); // current goal
	PredicateList::ptr_type r = gl.Tail(); // remaining goals

	RuleList p = SelectRules(ruleBase, g, chr);    // RuleBase, Renumbered at chr

#if MG_DEBUG_PROLOG > 2
	DBG_TRACE(("Goal       = %s", AsString(g).c_str()));
	DBG_TRACE(("Remaining  = %s", AsString(r).c_str()));
	DBG_TRACE(("Env        = %s", AsString(e).c_str()));
#endif MG_DEBUG_PROLOG > 2

	AnswerList sol = AnswerList();

	while (!p.IsEmpty())
	{
		Rule::ptr_type rule = p.Head();
		AssocList uni = UnifyRobinson(g, rule.Head(), e);
		if (!uni.IsFailed())
		{
#ifdef MG_DEBUG_PROLOG
			DBG_TRACE(("Unified at : %s", AsString(chr).c_str()));
			DBG_TRACE(("Predicate  : %s", AsString(rule.Head()).c_str()));
			DBG_TRACE(("Goal       : %s", AsString(g).c_str()));
			DBG_TRACE(("Unification: %s", AsString(uni).c_str()));
			DBG_TRACE(("Conditions : %s", AsString(rule.Tail()).c_str()));
#endif
			sol = Prove(ruleBase, rule.Tail().Concat(r), uni, chr+1).Concat(sol);
#ifdef MG_DEBUG_PROLOG
			DBG_TRACE(("Solved level: %s", AsString(chr).c_str()));
			DBG_TRACE(("Solutions   : %s", AsString(sol).c_str()));
#endif
		}
		p = p.Tail();
	}
	return sol;
}

Answer SayAnswer(AssocList::ptr_type env)
{
//	cout <<"\n\nAnswer:";
//	cout << env;
/*
	while (!env.IsEmpty())
	{
		Assoc a = env.First();
		cout << "\n var " << a.Key() << " = " << a.Val();
		env = env.Tail();
	}
*/
	return env;
}

AnswerList Solve(RuleList::ptr_type ruleBase, PredicateList::ptr_type res) // List of goals; NOT renumbered
	//	See: [Boizumault93], p.45
{
	return Prove(ruleBase, res, AssocList(), 2);
}

RuleList RewriteGoals(PredicateList::ptr_type goals, AnswerList::ptr_type answers)
{
	return (answers.EndP())
		? RuleList()
		: RuleList(answers.Head().ApplyMany(goals),
				RewriteGoals(goals, answers.Tail()));
}

